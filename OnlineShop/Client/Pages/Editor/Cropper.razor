@using Blazor.Cropper
@using System.Drawing;
@using System.IO
@using OnlineShop.Client.Services.State
@using OnlineShop.Server.DB.Mappers
@using SixLabors.ImageSharp
@using SixLabors.ImageSharp.Formats
@using SixLabors.ImageSharp.Formats.Bmp
@using SixLabors.ImageSharp.PixelFormats
@inject IJSRuntime js;
@inject AppState _appState;

<MudPaper Class="">
    <h3>Cropper</h3>
    <InputFile id="input1" OnChange="OnInputFileChange"></InputFile>

    @if (file != null)
    {
        <Blazor.Cropper.Cropper
            MaxCropedHeight="500"
            MaxCropedWidth="500"
            CropperHeight="600"
            AspectRatio="proportion == 0 ? 1 : proportion"
            @ref="cropper"
            RequireAspectRatio="true"
            InputId="input1"
            ImageFile="file"
            @bind-Ratio="ratio"
            PureCSharpProcessing="false"
            OnSizeChanged="t =>{ width = t.Item1; height = t.Item2; }">
        </Blazor.Cropper.Cropper>
        <footer class="modal-card-foot">
            @* <MudSlider @bind-Value="proportion" Min="1" Max="8" Color="Color.Info">Value: @proportion.ToString()</MudSlider> *@

            @if (cropper != null)
            {
                <div>
                    width: @width |
                    height: @height
                </div>
                <MudChipSet Filter="filter" SelectedChipChanged="SelectProportion" Mandatory="true">
                    <MudChip Default="true" Text="32x32" Value="1f"></MudChip>
                    <MudChip Text="32x64" Value="2f"></MudChip>
                    <MudChip Text="32x48" Value="1.5f"></MudChip>
                </MudChipSet>
                <span>@proportion</span>
            }
            <MudChipSet Filter="filter" SelectedChipChanged="SelectPalette" Mandatory="true">
                @if (_colorPalettes != null)
                {
                    @for (int i = 0; i < _colorPalettes.Length; i++)
                    {
                        <MudChip Text="@_colorPalettes[i].Name" Value="@_colorPalettes[i]"></MudChip>
                    }
                }
            </MudChipSet>

        </footer>
    }

    <MudButton @onclick="DoneCrop">Save</MudButton>
    @if (!string.IsNullOrEmpty(imgUrl) && !parsing)
    {
        <img src="@imgUrl"/>
    }

    @if (pixelizeHEXImage != null)
    {
        <Preview Pixels="pixelizeHEXImage"/>
    }
</MudPaper>

@code {
    Blazor.Cropper.Cropper cropper;
    private ElementReference _image;
    IBrowserFile file;
    bool purecs = false;
    double width;
    double height;
    string imgUrl = "";
    bool parsing = false;
    double proportion = 1d;
    double ratio = 1;

    bool filter = true;
    MudChip selected;
    private string[]? selectedValues;

    private Rgba32[,] pixelizeImage;

    private Rgba32[] grayscalePalette = new Rgba32[7]
    {
        new Rgba32(0.1428f, 0.1428f, 0.1428f, 1),
        new Rgba32(0.2856f, 0.2856f, 0.2856f, 1),
        new Rgba32(0.4284f, 0.4284f, 0.4284f, 1),
        new Rgba32(0.5712f, 0.5712f, 0.5712f, 1),
        new Rgba32(0.714f, 0.714f, 0.714f, 1),
        new Rgba32(0.8568f, 0.8568f, 0.8568f, 1),
        new Rgba32(1, 1, 1, 1),
    //new Rgba32(0.9996f, 0.9996f, 0.9996f, 1),
    };

    private string[,] pixelizeHEXImage;
    private ColorPalette hexPalette = new ColorPalette {Color1 = "#1c1c1c", Color2 = "#404040", Color3 = "#616161", Color4 = "#8a8a8a", Color5 = "#b3b3b3", Color6 = "#d9d9d9", Color7 = "#f5f5f5"};
    ColorPalette[] _colorPalettes;

    protected override async Task OnInitializedAsync()
    {
        _colorPalettes = await _appState.ColorPalettesRepository.GetPalettes();
    }

    async Task OnInputFileChange(InputFileChangeEventArgs args)
    {
        await js.InvokeVoidAsync("console.log", DateTime.Now.ToString());
        file = args.File;
    }

    void OnRatioChange(ChangeEventArgs args)
    {
        ratio = int.Parse(args.Value.ToString()) / 100.0;
    }

    async Task DoneCrop()
    {
        var args = await cropper.GetCropedResult();
        file = null;
        parsing = true;
        base.StateHasChanged();
        await Task.Delay(10); // a hack, otherwise prompt won't show
        await js.InvokeVoidAsync("console.log", "converted!");
        var base64string = await args.GetBase64Async();
        byte[] bitmap = await new ImageCroppedResult(base64string).GetDataAsync();
        Image<Rgba32> image = Image.Load(bitmap);
        imgUrl = $"data:image/png;base64,{base64string}";

        Pixelize(image);
        parsing = false;
    }

    private struct Sums
    {
        /// <summary>
    /// Gets or sets the alpha component.
    /// </summary>
        public int A { get; set; }

        /// <summary>
    /// Gets or sets the red component.
    /// </summary>
        public int R { get; set; }

        /// <summary>
    /// Gets or sets the blue component.
    /// </summary>
        public int B { get; set; }

        /// <summary>
    /// Gets or sets the green component.
    /// </summary>
        public int G { get; set; }

        /// <summary>
    /// Gets or sets the total count.
    /// </summary>
        public int T { get; set; }
    }

    public void Pixelize(Image<Rgba32> image)
    {
    //50x50
        int blockSizeX = (int) MathF.Truncate(image.Width / 32);
        int blockSizeY = (int) MathF.Truncate(image.Height / 32);
        pixelizeImage = new Rgba32[32, 32];
        pixelizeHEXImage = new string[32, 32];
        float minGrayscaled = 1.1f;
        float maxGrayscaled = -0.1f;

    //                  image.Width += blockSizeX
        for (int x = 0; x < 32; x++)
        {
    //                  image.Height += blockSizeY
            for (int y = 0; y < 32; y++)
            {
                var sums = new Sums();

                for (int xx = 0; xx < blockSizeX; ++xx)
                {
                    for (int yy = 0; yy < blockSizeY; ++yy)
                    {
                        if (x * blockSizeY + xx >= image.Width || y * blockSizeY + yy >= image.Height)
                        {
                            continue;
                        }

                        Rgba32 color = image[x * blockSizeY + xx, y * blockSizeY + yy];
                        sums.A += color.A;
                        sums.R += color.R;
                        sums.G += color.G;
                        sums.B += color.B;
                        sums.T++;
                    }
                }

    //Контрасность, суть алгоритма
    //Найти диапазон цветов, использующихся в пикселизованной картинке с argb glayscale цветами
    //От каждого цвета матрицы пикс. изображения отнять минимальное значение цвета
    //разделить получившейся цвет на определенную константу, которая распределяет цвета по палитрам

    //Rgba32 average = new Rgba32((float)sums.R / sums.T / 255, (float)sums.G / sums.T / 255, (float)sums.B / sums.T / 255, 1);
                float averageGrayscaled = (sums.R * 0.2126f + sums.G * 0.7152f + sums.B * 0.0722f) / sums.T / 255;

    /*
                //нормальное распределение цветов
                int paletteColorIndex = (int)(grayscaled / 0.16669);
                pixelizeImage[x, y] = grayscalePalette[paletteColorIndex];
                */

    /*
                //повышенная контранстность
                 */
                if (averageGrayscaled > maxGrayscaled)
                    maxGrayscaled = averageGrayscaled;
                else if (averageGrayscaled < minGrayscaled)
                    minGrayscaled = averageGrayscaled;

                pixelizeImage[x, y] = new Rgba32(averageGrayscaled, averageGrayscaled, averageGrayscaled, 1);
            }
        }

        float grayscaledRange = maxGrayscaled - minGrayscaled;
        float divider = grayscaledRange / 6;
        int colorIndex;
        for (int x = 0; x < pixelizeImage.GetLength(0); x++)
        {
            for (int y = 0; y < pixelizeImage.GetLength(1); y++)
            {
                float t = (float) pixelizeImage[x, y].R / 255;
                colorIndex = (int) ((t - minGrayscaled) / divider);
    //if (colorIndex > 6) colorIndex = 6;
    //else if (colorIndex < 0) colorIndex = 0;
                pixelizeImage[x, y] = grayscalePalette[colorIndex];
                switch (colorIndex)
                {
                    case 0:
                        pixelizeHEXImage[x, y] = hexPalette.Color1;
                        break;
                    case 1:
                        pixelizeHEXImage[x, y] = hexPalette.Color2;
                        break;
                    case 2:
                        pixelizeHEXImage[x, y] = hexPalette.Color3;
                        break;
                    case 3:
                        pixelizeHEXImage[x, y] = hexPalette.Color4;
                        break;
                    case 4:
                        pixelizeHEXImage[x, y] = hexPalette.Color5;
                        break;
                    case 5:
                        pixelizeHEXImage[x, y] = hexPalette.Color6;
                        break;
                    default:
                        pixelizeHEXImage[x, y] = hexPalette.Color7;
                        break;
                }
            }
        }
    }

    async void GetCropResult()
    {
        var re = await cropper.GetCropedResult();
        await js.InvokeAsync<Task>("previewResult", _image, re.Img);
    }

    private void SelectProportion(MudChip chip)
    {
        selected = chip;
        if (selected != null)
            proportion = 1 / (float) selected.Value;
    }

    private void SelectPalette(MudChip chip)
    {
        selected = chip;
        if (selected != null)
            hexPalette = (ColorPalette) selected.Value;
    }

}